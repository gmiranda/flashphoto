<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <title>The CImg Library - C++ Template Image Processing Library</title>
    <meta content="David Tschumperle" name="author">
    <link rel="shortcut icon" type="image/x-icon" href="http://cimg.sourceforge.net/favicon.ico" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <link href="doxygen.css" rel="stylesheet" type="text/css">
  </head>
  <body bgcolor="#ffffff" fgcolor="#000000" alink="#ff0000" link="#0000ee" vlink="#551a8b">
    <table align="center" border="0" cellpadding="0" cellspacing="0" width="1024">
      <tbody>
        <tr>
          <td>
            <hr noshade="noshade" size="1" width="100%">
            <center> 
              <a href="http://cimg.sourceforge.net"><img src="../img/CImgLogo2.jpg" border="0"><img src="../img/CImgLogo.jpg" border="0"></a><br>
	      <table style="width: 100%; text-align: left;" border="0"
		cellpadding="2" cellspacing="2">
		<tbody>
		  <tr>
		    <td style="vertical-align: top; text-align: right;"><font
			face="Arial,Helvetica"><big>&nbsp;&nbsp;<b>C++ Template Image Processing Library.</b></big></font></td>
		    <td style="vertical-align: top; text-align: right;">
		      <a href="http://www.cnrs.fr/"><img src="../img/logoCNRS.gif" border="0"></a>&nbsp;
		      <a href="http://www.greyc.ensicaen.fr/EquipeImage"><img src="../img/logoGREYC.gif" border="0"></a>&nbsp;
		      <a href="http://www-sop.inria.fr"><img src="../img/logoINRIA.gif" border="0"></a>
		    </td>
		  </tr>
		</tbody>
	      </table>
	      </center>

            <hr noshade="noshade" size="1" width="100%">
            <center>
              <table
                style="width: 100%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(238, 238, 255);"
                border="0" cellpadding="3" cellspacing="0">
                <tbody>
                  <tr>
                    <td style="text-align: center; vertical-align: top;">
                      <font face="Arial,Helvetica" size="-1">
                        [<a target="_parent" href="../index.shtml">Introduction</a>]-
                        [<a target="_parent" href="../news.html">News</a>]-
                        [<a target="_parent" href="../download.shtml">Download</a>]-
                        [<a target="_parent" href="../screenshots.shtml">Screenshots</a>]-
                        [<a target="_parent" href="../reference/group__cimg__tutorial.html">Tutorial</a>]-
                        [<a target="_parent" href="http://sourceforge.net/forum/forum.php?forum_id=334630">Forums-Eng</a>]-
                        [<a target="_parent" href="http://sourceforge.net/forum/forum.php?forum_id=421080">Forums-Fr</a>]-
                        [<a target="_parent" href="../reference/index.html">Reference</a>]-
                        [<a target="_parent" href="http://sourceforge.net/projects/cimg/">SourceForge Repository</a> ]
                      </font></td>
                  </tr>
                </tbody>
              </table>
            </center>
            <hr noshade="noshade" size="1" width="100%">
            <noscript> </noscript>
          </td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
<!-- Generated by Doxygen 1.3.9 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>Using Image Loops.</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
The CImg Library provides different macros that define useful iterative loops over an image. Basically, it can be used to replace one or several <code>for(..)</code> instructions, but it also proposes interesting extensions to classical loops. Below is a list of all existing loop macros, classified in four different categories :<ul>
<li><a class="el" href="group__cimg__loops.html#lo1">Loops over the pixel buffer</a></li><li><a class="el" href="group__cimg__loops.html#lo4">Loops over image dimensions</a></li><li><a class="el" href="group__cimg__loops.html#lo5">Loops over interior regions and borders.</a></li><li><a class="el" href="group__cimg__loops.html#lo6">Loops using neighborhoods.</a></li></ul>
<h2><a class="anchor" name="lo1">
Loops over the pixel buffer</a></h2>
Loops over the pixel buffer are really basic loops that iterate a pointer on the pixel data buffer of a <code><a class="el" href="structcimg__library_1_1CImg.html">cimg_library::CImg</a></code> image. Two macros are defined for this purpose :<p>
<ul>
<li><b>cimg_map(img,ptr,T)</b> : This macro loops over the pixel data buffer of the image <code>img</code>, using a pointer <code>T* ptr</code>, starting from the end of the buffer (last pixel) till the beginning of the buffer (first pixel).<ul>
<li><code>img</code> must be a (non empty) <code><a class="el" href="structcimg__library_1_1CImg.html">cimg_library::CImg</a></code> image of pixels <code>T</code>.</li><li><code>ptr</code> is a pointer of type <code>T*</code>. This kind of loop should not appear a lot in your own source code, since this is a low-level loop and many functions of the CImg class may be used instead. Here is an example of use : <div class="fragment"><pre class="fragment">  CImg&lt;float&gt; img(320,200);
  cimg_map(img,ptr,<span class="keywordtype">float</span>) { *ptr=0; }      <span class="comment">// Equivalent to 'img.fill(0);'</span>
</pre></div></li></ul>
</li></ul>
<p>
<ul>
<li><b>cimg_mapoff(img,off)</b> : This macro loops over the pixel data buffer of the image <code>img</code>, using an offset <code></code>, starting from the beginning of the buffer (first pixel, <code>off=0</code>) till the end of the buffer (last pixel value, <code>off = img.size()-1</code>).<ul>
<li><code>img</code> must be a (non empty) cimg_library::CImg&lt;T&gt; image of pixels <code>T</code>.</li><li><code>off</code> is an inner-loop variable, only defined inside the scope of the loop.</li></ul>
</li></ul>
<p>
Here is an example of use : <div class="fragment"><pre class="fragment">  CImg&lt;float&gt; img(320,200);
  cimg_mapoff(img,off) { img[off]=0; }  <span class="comment">// Equivalent to 'img.fill(0);'</span>
</pre></div><h2><a class="anchor" name="lo4">
Loops over image dimensions</a></h2>
The following loops are probably the most used loops in image processing programs. They allow to loop over the image along one or several dimensions, along a raster scan course. Here is the list of such loop macros for a single dimension :<ul>
<li><b>cimg_mapX(img,x)</b> : equivalent to : <code>for (int x=0; x&lt;img.dimx(); x++)</code>.</li><li><b>cimg_mapY(img,y)</b> : equivalent to : <code>for (int y=0; y&lt;img.dimy(); y++)</code>.</li><li><b>cimg_mapZ(img,z)</b> : equivalent to : <code>for (int z=0; z&lt;img.dimz(); z++)</code>.</li><li><b>cimg_mapV(img,v)</b> : equivalent to : <code>for (int v=0; v&lt;img.dimv(); v++)</code>.</li></ul>
<p>
Combinations of these macros are also defined as other loop macros, allowing to loop directly over 2D, 3D or 4D images :<ul>
<li><b>cimg_mapXY(img,x,y)</b> : equivalent to : <code>cimg_mapY(img,y)</code> <code>cimg_mapX(img,x)</code>.</li><li><b>cimg_mapXZ(img,x,z)</b> : equivalent to : <code>cimg_mapZ(img,z)</code> <code>cimg_mapX(img,x)</code>.</li><li><b>cimg_mapYZ(img,y,z)</b> : equivalent to : <code>cimg_mapZ(img,z)</code> <code>cimg_mapY(img,y)</code>.</li><li><b>cimg_mapXV(img,x,v)</b> : equivalent to : <code>cimg_mapV(img,v)</code> <code>cimg_mapX(img,x)</code>.</li><li><b>cimg_mapYV(img,y,v)</b> : equivalent to : <code>cimg_mapV(img,v)</code> <code>cimg_mapY(img,y)</code>.</li><li><b>cimg_mapZV(img,z,v)</b> : equivalent to : <code>cimg_mapV(img,v)</code> <code>cimg_mapZ(img,z)</code>.</li><li><b>cimg_mapXYZ(img,x,y,z)</b> : equivalent to : <code>cimg_mapZ(img,z)</code> <code>cimg_mapXY(img,x,y)</code>.</li><li><b>cimg_mapXYV(img,x,y,v)</b> : equivalent to : <code>cimg_mapV(img,v)</code> <code>cimg_mapXY(img,x,y)</code>.</li><li><b>cimg_mapXZV(img,x,z,v)</b> : equivalent to : <code>cimg_mapV(img,v)</code> <code>cimg_mapXZ(img,x,z)</code>.</li><li><b>cimg_mapYZV(img,y,z,v)</b> : equivalent to : <code>cimg_mapV(img,v)</code> <code>cimg_mapYZ(img,y,z)</code>.</li><li><b>cimg_mapXYZV(img,x,y,z,v)</b> : equivalent to : <code>cimg_mapV(img,v)</code> <code>cimg_mapXYZ(img,x,y,z)</code>.</li></ul>
<p>
<ul>
<li>For all these loops, <code>x</code>,<code>y</code>,<code>z</code> and <code>v</code> are inner-defined variables only visible inside the scope of the loop. They don't have to be defined before the call of the macro.</li><li><code>img</code> must be a (non empty) <a class="el" href="structcimg__library_1_1CImg.html">cimg_library::CImg</a> image.</li></ul>
<p>
Here is an example of use that creates an image with a smooth color gradient : <div class="fragment"><pre class="fragment">  CImg&lt;unsigned char&gt; img(256,256,1,3);       <span class="comment">// Define a 256x256 color image</span>
  cimg_mapXYV(img,x,y,v) { img(x,y,v) = (x+y)*(v+1)/6; }
  img.<a class="code" href="structcimg__library_1_1CImg.html#z19_0">display</a>(<span class="stringliteral">"Color gradient"</span>);
</pre></div><h2><a class="anchor" name="lo5">
Loops over interior regions and borders.</a></h2>
Similar macros are also defined to loop only on the border of an image, or inside the image (excluding the border). The border may be several pixel wide :<p>
<ul>
<li><b>cimg_imapX(img,x,n)</b> : Loop along the x-axis, except for pixels inside a border of <code>n</code> pixels wide.</li><li><b>cimg_imapY(img,y,n)</b> : Loop along the y-axis, except for pixels inside a border of <code>n</code> pixels wide.</li><li><b>cimg_imapZ(img,z,n)</b> : Loop along the z-axis, except for pixels inside a border of <code>n</code> pixels wide.</li><li><b>cimg_imapV(img,v,n)</b> : Loop along the v-axis, except for pixels inside a border of <code>n</code> pixels wide.</li><li><b>cimg_imapXY(img,x,y,n)</b> : Loop along the (x,y)-axes, excepted for pixels inside a border of <code>n</code> pixels wide.</li><li><b>cimg_imapXYZ(img,x,y,z,n)</b> : Loop along the (x,y,z)-axes, excepted for pixels inside a border of <code>n</code> pixels wide.</li></ul>
<p>
And also :<p>
<ul>
<li><b>cimg_bmapX(img,x,n)</b> : Loop along the x-axis, only for pixels inside a border of <code>n</code> pixels wide.</li><li><b>cimg_bmapY(img,y,n)</b> : Loop along the y-axis, only for pixels inside a border of <code>n</code> pixels wide.</li><li><b>cimg_bmapZ(img,z,n)</b> : Loop along the z-axis, only for pixels inside a border of <code>n</code> pixels wide.</li><li><b>cimg_bmapV(img,v,n)</b> : Loop along the z-axis, only for pixels inside a border of <code>n</code> pixels wide.</li><li><b>cimg_bmapXY(img,x,y,n)</b> : Loop along the (x,y)-axes, only for pixels inside a border of <code>n</code> pixels wide.</li><li><b>cimg_bmapXYZ(img,x,y,z,n)</b> : Loop along the (x,y,z)-axes, only for pixels inside a border of <code>n</code> pixels wide.</li></ul>
<p>
<ul>
<li>For all these loops, <code>x</code>,<code>y</code>,<code>z</code> and <code>v</code> are inner-defined variables only visible inside the scope of the loop. They don't have to be defined before the call of the macro.</li><li><code>img</code> must be a (non empty) <a class="el" href="structcimg__library_1_1CImg.html">cimg_library::CImg</a> image.</li><li>The constant <code>n</code> stands for the size of the border.</li></ul>
<p>
Here is an example of use, to create a 2d grayscale image with two different intensity gradients : <div class="fragment"><pre class="fragment">  CImg&lt;&gt; img(256,256);
  cimg_imapXY(img,x,y,50) img(x,y) = x+y;
  cimg_bmapXY(img,x,y,50) img(x,y) = x-y;
  img.display();
</pre></div><h2><a class="anchor" name="lo6">
Loops using neighborhoods.</a></h2>
Inside an image loop, it is often useful to get values of neighborhood pixels of the current pixel at the loop location. The CImg Library provides a very smart and fast mechanism for this purpose, with the definition of several loop macros that remember the neighborhood values of the pixels. The use of these macros can highly optimize your code, and also simplify your program.<h3><a class="anchor" name="lo7">
Neighborhood-based loops for 2D images</a></h3>
For 2D images, the neighborhood-based loop macros are :<p>
<ul>
<li><b>cimg_map2x2(img,x,y,z,v,I)</b> : Loop along the (x,y)-axes using a centered 2x2 neighborhood.</li><li><b>cimg_map3x3(img,x,y,z,v,I)</b> : Loop along the (x,y)-axes using a centered 3x3 neighborhood.</li><li><b>cimg_map4x4(img,x,y,z,v,I)</b> : Loop along the (x,y)-axes using a centered 4x4 neighborhood.</li><li><b>cimg_map5x5(img,x,y,z,v,I)</b> : Loop along the (x,y)-axes using a centered 5x5 neighborhood.</li></ul>
<p>
For all these loops, <code>x</code> and <code>y</code> are inner-defined variables only visible inside the scope of the loop. They don't have to be defined before the call of the macro. <code>img</code> is a non empty CImg&lt;T&gt; image. <code>z</code> and <code>v</code> are constants that define on which image slice and vector channel the loop must apply (usually both 0 for grayscale 2D images). Finally, <code>I</code> is the 2x2, 3x3, 4x4 or 5x5 neighborhood that will be updated with the correct pixel values during the loop (see <a class="el" href="group__cimg__loops.html#lo9">Defining neighborhoods</a>).<h3><a class="anchor" name="lo8">
Neighborhood-based loops for 3D images</a></h3>
For 3D images, the neighborhood-based loop macros are :<p>
<ul>
<li><b>cimg_map2x2x2(img,x,y,z,v,I)</b> : Loop along the (x,y,z)-axes using a centered 2x2x2 neighborhood.</li><li><b>cimg_map3x3x3(img,x,y,z,v,I)</b> : Loop along the (x,y,z)-axes using a centered 3x3x3 neighborhood.</li></ul>
<p>
For all these loops, <code>x</code>, <code>y</code> and <code>z</code> are inner-defined variables only visible inside the scope of the loop. They don't have to be defined before the call of the macro. <code>img</code> is a non empty CImg&lt;T&gt; image. <code>v</code> is a constant that defines on which image channel the loop must apply (usually 0 for grayscale 3D images). Finally, <code>I</code> is the 2x2x2 or 3x3x3 neighborhood that will be updated with the correct pixel values during the loop (see <a class="el" href="group__cimg__loops.html#lo9">Defining neighborhoods</a>).<h3><a class="anchor" name="lo9">
Defining neighborhoods</a></h3>
The CImg library defines a neighborhood as a set of named <em>variables</em> or <em>references</em>, declared using specific CImg macros :<p>
<ul>
<li><b>CImg_2x2(I,type)</b> : Define a 2x2 neighborhood named <code>I</code>, of type <code>type</code>.</li><li><b>CImg_3x3(I,type)</b> : Define a 3x3 neighborhood named <code>I</code>, of type <code>type</code>.</li><li><b>CImg_4x4(I,type)</b> : Define a 4x4 neighborhood named <code>I</code>, of type <code>type</code>.</li><li><b>CImg_5x5(I,type)</b> : Define a 5x5 neighborhood named <code>I</code>, of type <code>type</code>.</li><li><b>CImg_2x2x2(I,type)</b> : Define a 2x2x2 neighborhood named <code>I</code>, of type <code>type</code>.</li><li><b>CImg_3x3x3(I,type)</b> : Define a 3x3x3 neighborhood named <code>I</code>, of type <code>type</code>.</li></ul>
<p>
Actually, <code>I</code> is a <em>generic</em> <em>name</em> for the neighborhood. In fact, these macros declare a <em>set</em> of new variables. For instance, defining a 3x3 neighborhood <code>CImg_3x3(I,float)</code> declares 9 different float variables <code>Ipp</code>,<code>Icp</code>,<code>Inp</code>,<code>Ipc</code>,<code>Icc</code>,<code>Inc</code>,<code>Ipn</code>,<code>Icn</code>,<code>Inn</code> which correspond to each pixel value of a 3x3 neighborhood. Variable indices are <code>p</code>,<code>c</code> or <code>n</code>, and stand respectively for <em>'previous'</em>, <em>'current'</em> and <em>'next'</em>. First indice denotes the <code>x-axis</code>, second indice denotes the <code>y-axis</code>. Then, the names of the variables are directly related to the position of the corresponding pixels in the neighborhood. For 3D neighborhoods, a third indice denotes the <code>z-axis</code>. Then, inside a neighborhood loop, you will have the following equivalence :<ul>
<li><code>Ipp = img(x-1,y-1)</code></li><li><code>Icn = img(x,y+1)</code></li><li><code>Inp = img(x+1,y-1)</code></li><li><code>Inpc = img(x+1,y-1,z)</code></li><li><code>Ippn = img(x-1,y-1,z+1)</code></li><li>and so on...</li></ul>
<p>
For bigger neighborhoods, such as 4x4 or 5x5 neighborhoods, two additionnal indices are introduced : <code>a</code> (stands for <em>'after'</em>) and <code>b</code> (stands for <em>'before'</em>), so that :<ul>
<li><code>Ibb = img(x-2,y-2)</code></li><li><code>Ina = img(x+1,y+2)</code></li><li>and so on...</li></ul>
<p>
The value of a neighborhood pixel outside the image range (image border problem) is automatically set to the same values than the nearest valid pixel in the image (this is also called the <em>Neumann</em> <em>border</em> <em>condition</em>).<h3><a class="anchor" name="lo10">
Neighborhood as a reference</a></h3>
It is also possible to define neighborhood variables as references to classical C-arrays or CImg&lt;T&gt; images, instead of allocating new variables. This is done by adding <code>_ref</code> to the macro names used for the neighborhood definition :<p>
<ul>
<li><b>CImg_2x2_ref(I,type,tab)</b> : Define a 2x2 neighborhood named <code>I</code>, of type <code>type</code>, as a reference to <code>tab</code>.</li><li><b>CImg_3x3_ref(I,type,tab)</b> : Define a 3x3 neighborhood named <code>I</code>, of type <code>type</code>, as a reference to <code>tab</code>.</li><li><b>CImg_4x4_ref(I,type,tab)</b> : Define a 4x4 neighborhood named <code>I</code>, of type <code>type</code>, as a reference to <code>tab</code>.</li><li><b>CImg_5x5_ref(I,type,tab)</b> : Define a 5x5 neighborhood named <code>I</code>, of type <code>type</code>, as a reference to <code>tab</code>.</li><li><b>CImg_2x2x2_ref(I,type,tab)</b> : Define a 2x2x2 neighborhood named <code>I</code>, of type <code>type</code>, as a reference to <code>tab</code>.</li><li><b>CImg_3x3x3_ref(I,type,tab)</b> : Define a 3x3x3 neighborhood named <code>I</code>, of type <code>type</code>, as a reference to <code>tab</code>.</li></ul>
<p>
<code>tab</code> can be a one-dimensionnal C-style array, or a non empty <code>CImg&lt;T&gt;</code> image. Both objects must have same sizes as the considered neighborhoods.<h3><a class="anchor" name="lo11">
Example codes</a></h3>
More than a long discussion, the above example will demonstrate how to compute the gradient norm of a 3D volume using the <code>cimg_map3x3x3()</code> loop macro :<p>
<div class="fragment"><pre class="fragment">  CImg&lt;float&gt; volume(<span class="stringliteral">"IRM.hdr"</span>);        <span class="comment">// Load an IRM volume from an Analyze7.5 file</span>
  CImg_3x3x3(I,<span class="keywordtype">float</span>);                  <span class="comment">// Define a 3x3x3 neighborhood</span>
  CImg&lt;float&gt; gradnorm(volume,<span class="keyword">false</span>);   <span class="comment">// Create an image with same size as 'volume'</span>
  cimg_map3x3x3(volume,x,y,z,0,I) {     <span class="comment">// Loop over the volume, using the neighborhood I</span>
    <span class="keyword">const</span> <span class="keywordtype">float</span> ix = 0.5f*(Incc-Ipcc);  <span class="comment">// Compute the derivative along the x-axis.</span>
    <span class="keyword">const</span> <span class="keywordtype">float</span> iy = 0.5f*(Icnc-Icpc);  <span class="comment">// Compute the derivative along the y-axis.</span>
    <span class="keyword">const</span> <span class="keywordtype">float</span> iz = 0.5f*(Iccn-Iccp);  <span class="comment">// Compute the derivative along the z-axis.</span>
    gradnorm(x,y,z) = std::sqrt(ix*ix+iy*iy+iz*iz);  <span class="comment">// Set the gradient norm in the destination image</span>
  }
  gradnorm.display(<span class="stringliteral">"Gradient norm"</span>);
</pre></div><p>
And the following example shows how to deal with neighborhood references to blur a color image by averaging pixel values on a 5x5 neighborhood.<p>
<div class="fragment"><pre class="fragment">  CImg&lt;unsigned char&gt; src(<span class="stringliteral">"image_color.jpg"</span>), dest(src,<span class="keyword">false</span>), neighbor(5,5);  <span class="comment">// Image definitions.</span>
  <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> uchar;             <span class="comment">// Avoid space in the second parameter of the macro CImg_5x5 below.</span>
  CImg_5x5_ref(N,uchar,neighbor);          <span class="comment">// Define a 5x5 neighborhood as a reference to the 5x5 image neighbor.</span>
  cimg_mapV(src,k)                         <span class="comment">// Standart loop on color channels</span>
     cimg_map5x5(src,x,y,0,k,N)            <span class="comment">// 5x5 neighborhood loop.</span>
       dest(x,y,k) = neighbor.sum()/(5*5); <span class="comment">// Averaging pixels to filter the color image.</span>
  CImgl&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; visu(src,dest);
  visu.display("Original + Filtered");     <span class="comment">// Display both original and filtered image.</span>
</pre></div><p>
Note that in this example, we didn't use directly the variables Nbb,Nbp,..,Ncc,... since there are only references to the neighborhood image <code>neighbor</code>. We rather used a member function of <code>neighbor</code>.<p>
As you can see, explaining the use of the CImg neighborhood macros is actually more difficult than using them ! <hr size="1"><address style="align: right;"><small>Generated on Mon Jul 4 09:51:36 2005 for The CImg Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9 </small></address>
</body>
</html>
